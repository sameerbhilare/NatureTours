/*
    We are implementing "The 7-1 Pattern".
    "The 7-1 Pattern" architecture is really designed to handle large multi-page websites or web apps.
    So maybe for a small landing page like this project, this might seem like a bit too much, a bit overkill.
    But once you start working on a huge project then you'll appreciate how this makes things easier, 
    so it's really important to have an architecture like this in place 
    especially when we're working on a larger project.
*/
/*  
    This main file only serves to import all the other files. 
    So, there will be no code here in this file except for all these import declarations.
*/
/*
    What the clearfix does is to append a pseudo element after the element which will then clear these floats.
*/
/*
    We ae going to write media queries considering below breakpoints for different devices.
    0 - 600px       Phone
    601 - 900px     Tablet Portrait
    901 - 1200px    Tablet Landscape
    [1200 - 1800]   Normal styles (of Desktop First approach) apply (basically without any media queries).
    1800+           Big Desktops
*/
/*
    Approach 1: Not efficient. Not Recommended.
    content defined from .scss where this mixin respond-phone is included
    is passed into this mixin and this whole block is then replaced in the .scss
    where this mixin is included (with @include).

    @mixin respond-phone {
        @media (max-width: 600px) { @content };
    }
*/
/*
    Approach 2: The better approach
    $breakpoint argument choices:
        - phone
        - tab-port
        - tab-land
        - big-desktop
    content defined from .scss where this mixin respond is included,
    is passed into this mixin and this whole block is then replaced in the .scss
    where this mixin is included (with @include).

    We're actually not going to use pixels in the media queries here.
    That's because if the user changes the default font size in the browser, 
    then the media queries would not be affected by that. And we won't get desired results.


    Important note about rems and ems in media queries -
    ems and rems in media queries are NOT affected by a root font size setting.
    What that means is that 1rem or 1em in a media query is always 
    just equal to the font size which is coming from the browser.
    and that's by default 16 pixels, but if the user changes it to 20 pixels, 
    then it will be 20 pixels no matter what we have in our base/root font definition.

    We're going to use here is ems and not rems, because rems fail to work as intended 
    in some of the browsers. There's been some experiments done by people who understand 
    a lot of all of this, and the conclusion basically is that ems are the BEST option for media queries.

    Considering 1em = 16px,
        600px = 600/16 = 37.5em 
        900px = 900/16 = 56.25em
        1200px = 1200/16 = 75em
        1800px = 1800/16 = 112.5em

    This (ems) will be converted to pixels and will be adopted to the font size that the user set for the browser.
    So, it's a more accessible and dynamic solution here instead of using the pixels.

    ORDER: base + typography > General Layout + Grid > Page Layout > Components

*/
/*
    In the abstracts folder we're only going to put code that's not going to output any css.
    e.g. variables, mixins, functions and stuff like that.
*/
/*
    base file for animations.
*/
/* with keyframes at-rule, we can control how animation should work at any point of time between start and end. */
/* For the browser performance, it's best to only ever animate two different properties. 
    One is opacity, and the other one is the transform property. 
    The browsers are optimized for these two properties.*/
@keyframes moveInLeft {
  /* what should happen at the start which is 0% */
  0% {
    opacity: 0;
    transform: translateX(-10rem);
    /* along the X axis, initial position is a lot more to the left */ }
  80% {
    opacity: 1;
    transform: translateX(1rem);
    /* intermediate position is slightly to the right. */ }
  /* what should happen at the end which is 100% */
  100% {
    opacity: 1;
    transform: translate(0);
    /* 0 to look exactly the way it looks without animations. */ } }

@keyframes moveInRight {
  /* what should happen at the start which is 0% */
  0% {
    opacity: 0;
    transform: translateX(10rem);
    /* initial position is a lot more to the right. + means right */ }
  80% {
    opacity: 1;
    transform: translateX(-1rem);
    /* intermediate position is slightly to the left. minus(-) means left */ }
  /* what should happen at the end which is 100% */
  100% {
    opacity: 1;
    transform: translate(0);
    /* 0 to look exactly the way it looks without animations. */ } }

@keyframes moveInBottom {
  /* what should happen at the start which is 0% */
  0% {
    opacity: 0;
    transform: translateY(1rem);
    /* initial position is a to the bottom. + means bottom */ }
  /* what should happen at the end which is 100% */
  100% {
    opacity: 1;
    transform: translate(0);
    /* 0 to look exactly the way it looks without animations. */ } }

/*
    The base folder will contain our basic project definitions like a project boiler plate.

    This base SASS file will be for the real low level basics, such as resets 
    and styles for the HTML and body element selectors.
    Note this file should be a partial so we can later import it into the main SASS file 
    (Sass feature: Partials & Imports).

    The PARTIAL files their name always starts with an underscore. e.g. _base.scss
    Now IMPORT this file into main.scss file without the underscore like this - @import "base/base"
*/
/* UNIVERSAL SELECTOR RESET
   By default, browsers apply a certain margin, and/or a certain padding, to some elements. 
   And we don't want that, obviously for consistency. * means Universal Selector.
   We should also declare selector for all after and before pseudo-elements so that the 
   declaration block will apply to all elements. 
 */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* Whenever we can use inheritance, we should use it 
     instead of using something like the universal selector (*). 
                             
     Using inherit keyword to force inheritance here.
                             
     box-sizing property by itself is not inherited, but by setting the box-sizing property 
     on Universal selector (so basically each and every element on the entire page) to inherit, 
     it'll automatically inherit whatever we put here on border-box. 
     So this is considered a slightly better practice by the CSS community 
     because it makes it a bit easier to change the box-sizing like in plugins or other components 
     where we might want to use a different property for box-sizing. 
     So it doesn't make a huge difference, just a slightly better practice 
     to do the box-sizing border-box like this. */
  box-sizing: inherit; }

/* Important: DECLARE ROOT font-size. */
html {
  /*  We should not set ROOT font-size in px. The problem is that by doing so we actually 
         override the browser font size setting that the user can manually change in the browser settings
         and many people actually do that. e.g. when they have bad sight and cannot see so good,
         then some people actually increase the default font size of their browser.
         So if we set our ROOT font-size in px, then we remove the ability for these people 
         to see our website properly because they can no longer change the default font size 
         (they can, but our root font size will not be affected by that anymore).
         So this is a really bad practice, and that is why we should set overall font size to a percentage,
         which will translate to a percentage of the font size given by the browser.
         Now the default font size, if the user doesn't change anything is 16 pixels.
         But here we want 10px for our ease because 1 rem = root font-size. so here 1 rem = 10px.
         So now it's easier for us to do calculations (w.r.t 10) while assigning 
         rem based font-sizes/length units. 
         If it were say 16px, then we would have to do lot more calculations in each selector.
         
         So Default browser font-size is 16px. 
         hence if we want root font-size to be 10 px, then 10/16 = 0.625 => 62.5% 
         So by default 62.5% translates to 10px (0.625 * 16).
         If user changes to 20px, then 62.5% translates to = 12.5px (0.625 * 20).
         If user changes to 22px, then 62.5% translates to 13.75px (0.625 * 22).
 
         So with this we allow the user to actually zoom in on the page automatically, 
         not only to change the font size, but to also to zoom in on the page, 
         because basically what happens is Not exactly zooming, 
         but increasing all of the measurements that we have on our page.
 
         This is really widely used technique in the CSS developer community 
         because it's so simple and yet so powerful.
 
         Note: rems are not supported below Internet Explorer 9.
     */
  font-size: 62.5%;
  /*font-size: 10px;*/
  /* ROOT font size. Why 10, bcz 1 rem = root font-size. so here 1 rem = 10px.
                            So now it's easier for us to do calculations (w.r.t 10)
                            while assigning rem based font-sizes/length units. If it were say 16px, 
                            then we would have to do lot more calculations in each selector. */
  scroll-behavior: smooth;
  /*
        Approach 1: Not efficient
        // including the mixin and setting its content.
        @include respond-phone {
            font-size: 50%;
        }
    */
  /*
        Approach 2: The better approach
    */
  /* SEQUENCE DOES MATTER. BECAUSE ONE MEDIA QUERY CAN BE APPLICABLE TO MORE THAN ONE BREAKPOINTS 
       SINCE WE ARE ONLY USING max-width, NOT BOTH max-width and min-width. 
       ALWAYS THE LARGER ONES BEFORE THE SMALLER ONES. */
  /* commenting this, because font-size for 'phone' and 'tab-port' is same 50%
       and logically whatever defined for 'tab-port' will apply for 'phone' as well
       because e.g. if screen size is 500px, then it is less than 600px (phone) but also less than 900px (tab-port)
       so this code is redundant, hence we can comment it.

       Note- we are only using max-width in one media query, so above logic applies.
       If we are using both min-width and max-width in one media query, then above logic will fail.
    @include respond(phone) {   // width < 600?
        font-size: 50%;
    } 
    */ }
  @media (max-width: 75em) {
    html {
      /* For Tablet Portrait, We want 1 rem to be 9px, means 9/16 = 56.25% */
      font-size: 56.25%; } }
  @media (max-width: 56.25em) {
    html {
      /* For Tablet Portrait, We want 1 rem to be 8px, means 8/16 = 50% */
      font-size: 50%; } }
  @media (min-width: 112.5em) {
    html {
      /* For Big Desktops, We want 1 rem to be 12px, means 12/16 = 75% */
      font-size: 75%; } }

/* Project wide definitions */
body {
  box-sizing: border-box;
  /* width = border + padding + width of the content, and 
                                height = border + padding + height of the content.
                                Plz note that margin is NOT added bcz it is outside box.
                             */
  padding: 3rem;
  /* to have a feel of showing everything into a box. */ }
  @media (max-width: 56.25em) {
    body {
      padding: 0; } }

/*
    Typography is the art and technique of arranging type to make written language readable and beautiful.
*/
/* Project wide definitions */
body {
  font-family: 'Lato', sans-serif;
  font-weight: 400;
  /*font-size: 16px;*/
  line-height: 1.7;
  color: #777; }

/*
    You could that this is a component but I think its a part of typography and 
    so this seems to the most intuitive place for me when I will be looking for the heading.
*/
.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  margin-bottom: 6rem;
  /* for mergin between header text and button. */ }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    /* properties for animations */
    animation-name: moveInLeft;
    animation-duration: 1s;
    /* total duration of the animation */
    /* this is a function which defines how the animation will proceed.     
          So, how fast or how slow the parameters defined in the keyframes(moveInLeft) happen over time.*/
    animation-timing-function: ease-out;
    /*ease-out: faster in the beginning, slower at the end. */
    /* animation-iteration-count: 3; number of times the animatiob should run */
    /* animation-delay: 3s;  time before starting the animation */ }
    @media (max-width: 37.5em) {
      .heading-primary--main {
        letter-spacing: 1rem;
        font-size: 5rem; } }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    /* available font-weights are - 100;300;400;700;900. 
                            - as mentioned in the Google Font which we included in our html page. */
    letter-spacing: 1.75rem;
    /* properties for animations */
    animation: moveInRight 1s ease-out;
    /* shorthand syntax using just animation property. */ }
    @media (max-width: 37.5em) {
      .heading-primary--sub {
        letter-spacing: .5rem; } }

.heading-secondary {
  font-size: 3.5rem;
  font-weight: 700;
  text-transform: uppercase;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  display: inline-block;
  /* When we set this background-clip property to text, it will clip the background (linear-gradient)
       to exactly the places where the text sits, so therefore this background image 
       or this gradient will ONLY be visible where the text is. */
  -webkit-background-clip: text;
  background-clip: text;
  /* Since the background image or this gradient will only be visible where the text is.
       Now what we want to see then is not actually the text, but the background image. 
       You can imagine that right now we have the background image only where the text is, 
       then on top of that, we have the text. Hence in order to see the background-image instead of the text
       we should mark the text as transparent.*/
  color: transparent;
  letter-spacing: .2rem;
  transition: all .2s; }
  @media (max-width: 56.25em) {
    .heading-secondary {
      font-size: 3rem; } }
  @media (max-width: 37.5em) {
    .heading-secondary {
      font-size: 2.5rem; } }
  .heading-secondary:hover {
    /* on transform, we can actually put multiple things at the same time that you want to transform.
           e.g. translate, translate x and y, scale, rotate, skew
           Let's skew in the x direction as well as in the y direction. */
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2);
    /*x, y, blur, color */ }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

/*
    utility classes are very simple reusable classes in CSS, which only have one simple goal 
    which makes them reusable.

    Having an utility classes allow our main components, or blocks, or elements 
    to stay independent and reusable across the page. 

    When we add a utility class, we really want to happen whatever we say.
    And so we actually want this to override everything else.
    And so we need to use the important keyword.
    So this is a normal practice to do it like this in the utility classes.
*/
.u-center-text {
  text-align: center !important; }

.u-margin-bottom-big {
  margin-bottom: 8rem !important; }
  @media (max-width: 56.25em) {
    .u-margin-bottom-big {
      margin-bottom: 5rem !important; } }

.u-margin-bottom-medium {
  margin-bottom: 4rem !important; }
  @media (max-width: 56.25em) {
    .u-margin-bottom-medium {
      margin-bottom: 3rem !important; } }

.u-margin-bottom-small {
  margin-bottom: 1.5rem !important; }

.u-margin-top-big {
  margin-top: 8rem !important; }

.u-margin-huge-big {
  margin-top: 10rem !important; }

.bg-video {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  z-index: -1;
  opacity: .15;
  overflow: hidden; }
  .bg-video__content {
    height: 100%;
    width: 100%;
    /* What we want to do is to actually occupy the entire section which the video is in, 
           but also while maintaining the aspect ratio.
           What object-fit:cover will do is that the element, in this case the video,
           will fill the entire parent while still maintaining its aspect ratio.
           And the part of the video that don't fit the parent element, will simply be clipped off. 
           
           The object-fit CSS property sets how the content of a replaced element, 
           such as an <img> or <video>, should be resized to fit its container. */
    object-fit: cover; }

/*
    The button is a component, because it's certainly a block. So, we can call it the component. 
    It's reusable across the page, it's independent, it works everywhere 
    and it's a building block that we can use wherever we want on our page.
*/
.btn {
  /* :link - pseudo class. pseudo-classes are a special state of a selector. 
        we use pseudo-classes to style elements under a special condition. */
  /* pseudo-elements allow us to style certain parts of elements. 
        the ::after pseudo-element adds like a virtual element right after the element that we're selecting.
        And we can then style that pseudo-element. */ }
  .btn, .btn:link, .btn:visited {
    text-decoration: none;
    text-transform: uppercase;
    padding: 1.5rem 4rem;
    /* top, bottom => 15px, left, right => 40px */
    display: inline-block;
    /* we should always do this if we want to give paddings, heights or width to an element */
    /* To align this button at the center, we don;t have to use transform and all. that wold be overkill for this
            That's bcz this is an inline block element and so it's treated as if it was text. 
            And so we can easily use the text's text-align property and set it to center. 
            (text-align:center is already done in it's parent element 'text-box' above)*/
    border-radius: 10rem;
    /* put higher number 100px +, then will have rounded left and right side.*/
    /* transition used for animation. Pass the properties that you want to animate on an event. */
    /* We need to put the transition animation to the initial state only. 
            So that transforms mentioned in :hover, :active will work. */
    transition: all 0.2s;
    /* all: all properties are enabled to be animated. */
    position: relative;
    /* this is required for .btn-white::after to work. */
    font-size: 1.6rem;
    border: none;
    cursor: pointer; }
  .btn:hover {
    transform: translateY(-3px);
    /* to move up the element. On Y axis: -ve means up, +ve means down */
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /*offset-x, offset-y, blur-radius, color*/
    /* when we hover the button, we want certain style for the pseudo-element (::after). 
            Defining pseudo-class for pseudo-element .btn:hover::after */ }
    .btn:hover::after {
      /* We want the element to grow and to fade out. */
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0;
      /* transition: all 0.4s; this will have effect on hover-in only not for hover-in and hover-out */ }
  .btn:active, .btn:focus {
    transform: translateY(-1px);
    /* to move up the element w.r.t initial state (:link, :visited).*/
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
    /*offset-x, offset-y, blur-radius, color*/
    /* .5 means 0.5 */
    /* In case of <button> element to avoid blue/black border around the button when it is clicked,
           we should not really remove simply the focus here for accessibility reasons. 
           We should say focus outline none. */
    outline: none; }
  .btn--white {
    background-color: #fff;
    color: #777;
    /* pseudo-element for btn-white.  .btn--white::after */ }
    .btn--white::after {
      background-color: #fff; }
  .btn--green {
    background-color: #55c57a;
    color: #fff;
    /* pseudo-element for btn-green.  .btn--green::after */ }
    .btn--green::after {
      background-color: #55c57a; }
  .btn::after {
    /* The trick here is to add an element that looks exactly like the button that we already have,
            but we put it behind the button. And when we hover out of the button, then this hidden pseudo-element
            amazingly goes back behind the button. */
    /* First, in order for an after pseudo-element to actually appear on the page,
            we need to specify its content property. 
            It doesn't matter what the content is. It can even be empty but we have to specify it.
            Otherwise it's not going to appear. Same thing with the display property. */
    content: "";
    /* content must be defined */
    display: inline-block;
    /* display must be defined */
    height: 100%;
    /* must be defined. 100% of the height of the actual/parent button */
    width: 100%;
    /* must be defined. 100% of the width of the actual/parent button */
    border-radius: 10rem;
    /* same as parent otherwise we will face issues in differentiating betn actual and pseudo-element*/
    /* this pseudo element should be (hidden) behind parent element. 
            absolute positioning needs to have a reference. And the reference is the first element
            with the relative position that it can find. */
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    /* z-index defines the position of the elements if they are one on top of another. */
    transition: all 0.4s;
    /* We need to put the transition animation to the initial state. 
                                so that it will apply for the scaling mentioned in .btn:hover::after 
                                and will have effect on both hover-in and hover-out */ }
  .btn--animated {
    animation: moveInBottom 0.5s ease-out 0.75s;
    /*name, duration, timing-function, delay */
    /* It will automatically apply the styles up to 0% mentioned in the keyframe (moveInBottom) 
            BEFORE the animation starts. 
            If this is not used, then we will see initial position of the button and it doesn't look good. */
    animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  /* for smaller units we dont have to use rem. We can use px. */
  padding: 3px;
  transition: all 0.2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0); }

.card {
  /* determines the distance between the z=0 plane and the user 
       in order to give a 3D-positioned element some perspective.
       e.g. in case of rotate, the edge kind of rotates towards the user, kind of some 3D effect. */
  perspective: 150rem;
  -moz-perspective: 150rem;
  position: relative;
  height: 52rem;
  /*  IMPORTANT CONSIDERATION: 
        basically when we rotate a card, we want to show the other card and NOT the backside of that specific card.
        Default behavour of rotate is, it will show the ACTUAL backside of that element only.
        But what we want is NOT to show the backside of that specific card, but altogether a different card.
        Hence in order to prevent the default behaviour of rotate, we set backface-visibility to hidden above.
    */
  /**************************
     * FRONT SIDE STYLING
     */
  /* This is a whole new element called "heading span." 
       So it's not a modifier of heading, and it's not an element of heading. */
  /**************************
     * BACK SIDE STYLING
     */
  /*
    The big problem with our card on mobile devices is that we have to actually touch it, 
    in order to rotate the cart. Because on touch devices, there's no such thing as a hover,
    and so, the only way to actually move the cart, is to click it, and that's not practical.
    So We don't want the price and book button to sit at the back of our cart.
    So, we basically have to actually, change the entire cart, this will be half a rewrite of this cart.
    */ }
  .card__side {
    height: 52rem;
    transition: all .8s ease;
    /* Note: When we took these cards out of their natural flow (by setting position to absolute),
                 then the parent(.card) gets collapsed and looses its height.
                 And so we don't get desired result like 'perspective' doesn't work as intended. 
                 When this happens with floats, we have a clear fix. 
                 But with position: absolute there is no such thing. 
                 The solution in this case is give same height to its parent (.card). */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    border-radius: 3px;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
    /* The image (card__picture--1) is basically overlapping the parent element, 
           hence we no longer have rounded corners. But we can fix this by setting overflow to hidden. */
    overflow: hidden;
    /* basically we want to hide the back part of a side bcz we have separate cards for front and back
           and when we rotate a card, we want to show the other card and not actualy rotate current card. */
    backface-visibility: hidden; }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      transform: rotateY(180deg); }
      .card__side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card__side--back-2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card__side--back-3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card__side--front {
    transform: rotateY(-180deg); }
  .card:hover .card__side--back {
    transform: rotateY(0deg); }
  .card__picture {
    background-size: cover;
    height: 23rem;
    /* The background-blend-mode property describes how the element's background image should blend/mix/combine.
           There are many options/values for this property, which we should try in Chrome DevTools. */
    background-blend-mode: screen;
    -webkit-clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    /* Currently clip-path in Google Chrome breaks the overflow: hidden. 
           Hence the card corners are no longer round. Solution is to set them again as below.*/
    border-top-left-radius: 3px;
    border-top-right-radius: 3px; }
    .card__picture--1 {
      /* IMPORTANT:
                w.r.t this file, the nat-5.jpg image is at ../../img/nat-5.jpg
                However we need to write the path w.r.t the style.css file, 
                that's because in the end all the Sass code will go into style.css file only. */
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url(../img/nat-5.jpg); }
    .card__picture--2 {
      /* IMPORTANT:
                w.r.t this file, the nat-6.jpg image is at ../../img/nat-6.jpg
                However we need to write the path w.r.t the style.css file, 
                that's because in the end all the Sass code will go into style.css file only. */
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url(../img/nat-6.jpg); }
    .card__picture--3 {
      /* IMPORTANT:
                w.r.t this file, the nat-7.jpg image is at ../../img/nat-7.jpg
                However we need to write the path w.r.t the style.css file, 
                that's because in the end all the Sass code will go into style.css file only. */
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url(../img/nat-7.jpg); }
  .card__heading {
    font-size: 2.8rem;
    font-weight: 500;
    color: #fff;
    text-transform: uppercase;
    text-align: right;
    position: absolute;
    top: 12rem;
    right: 2rem;
    width: 75%; }
  .card__heading-span {
    padding: 1rem 1.5rem;
    /* what box-decoration-break: clone does is to simply apply all the declarations 
           that we have in this selector (which in this case is only the padding) to all of the boxes
           that are created by this element. 
           So basically one element, two boxes, both styled in the same way. i.e. both with same padding. */
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone; }
    .card__heading-span--1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card__heading-span--2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card__heading-span--3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card__details {
    padding: 3rem; }
    .card__details ul {
      list-style: none;
      width: 80%;
      margin: 0 auto; }
      .card__details ul li {
        text-align: center;
        font-size: 1.5rem;
        padding: 1rem; }
        .card__details ul li:not(:last-child) {
          border-bottom: 1px solid #eee; }
  .card__cta {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    text-align: center; }
  .card__price-box {
    text-align: center;
    margin-bottom: 8rem;
    color: #fff; }
  .card__price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card__price-value {
    font-size: 6rem;
    font-weight: 100; }
  @media (max-width: 56.25em) {
    .card {
      height: auto;
      border-radius: 3px;
      background-color: #fff;
      box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
      /**************************
        * BACK SIDE STYLING
        */ }
      .card__side {
        height: auto;
        box-shadow: none;
        transition: all .8s ease;
        /* no longer in the absolute position, because we now, no longer have two sides occupying the same space
               So, first, we will have the front side, and then, after that, the back side.
            */
        position: relative; }
        .card__side--back {
          transform: rotateY(0);
          clip-path: polygon(0 15%, 100% 0, 100% 100%, 0 100%); }
      .card:hover .card__side--front {
        transform: rotateY(0); }
      .card_details {
        padding: 1rem 3rem; }
      .card__cta {
        position: relative;
        top: 0;
        left: 0;
        transform: translate(0);
        width: 100%;
        padding: 7rem 4rem 4rem 4rem; }
      .card__price-box {
        margin-bottom: 3rem; }
      .card__price-value {
        font-size: 4rem; } }

.composition {
  position: relative;
  /* IMPORTANT: What below selector means is  - 
       When we hover the composition, then select the composition photo/photos which is/are not hovered.*/ }
  .composition__photo {
    /* Always define the width of images in percentages if possible. (Responsive images)
           This way, it will nicely scale with the view port. */
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    border-radius: 2px;
    position: absolute;
    z-index: 10;
    transition: all .2s;
    outline-offset: 2rem; }
    @media (max-width: 56.25em) {
      .composition__photo {
        float: left;
        position: relative;
        width: 33.3333333%;
        box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.2); } }
    .composition__photo--p1 {
      top: -2rem;
      left: 0; }
      @media (max-width: 56.25em) {
        .composition__photo--p1 {
          top: 0;
          transform: scale(1.2); } }
    .composition__photo--p2 {
      top: 2rem;
      right: 0; }
      @media (max-width: 56.25em) {
        .composition__photo--p2 {
          top: -1rem;
          transform: scale(1.3);
          z-index: 100; } }
    .composition__photo--p3 {
      top: 10rem;
      left: 20%; }
      @media (max-width: 56.25em) {
        .composition__photo--p3 {
          top: 1rem;
          left: 0;
          transform: scale(1.1); } }
    .composition__photo:hover {
      /* Outline is similar to border.
               But with the outline, we can set outline offset.
               outline-offset is the space between the outline and the element on which the outline is applied. */
      outline: 1.5rem solid #55c57a;
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 20; }
  .composition:hover .composition__photo:not(:hover) {
    transform: scale(0.95); }

.form {
  /* When the placeholder is shown on the input element, then we need to hide the label.
       And as soon as user types something, the placeholder is gone and this pseudo-class (:placeholder-shown)
       is also NOT applied and hence below styles will also be NOT applied, and hence the label will
       automatically be visible with the animated effect as defined above in '&__label' selector.

       So it's not the input that we want to style, but we want to style the label.
       We want the label to be hidden and not the input. 
       But label is not child of input element, but it is a sibling of input element.
       '+' which means Adjacent sibling.
           Adjacent sibling is just a sibling that comes immediately AFTER the element that we select in the first place.
           We just need to make sure that the sibling that we have to select always has to be AFTER the first element.
           So in this case, the label needs to be AFTER the input element, otherwise it won't work.
       '~' means any general sibling selector, so this one works if there are more levels in-between those 2 elements.
    */
  /*  Basically we want to replace the 'actual radio button' with our 'custom radio button'.
        as our custom radio button has the exact same functionality as that of actual radio button. 
        So just hide the actual radio button.
        Btw the same way we can style check boxes as well. */
  /* each time we hit the radio label we have to make the circle (&__radio-button::after) appear in the center.
       So basically put the opacity of the after pseudo-element to 1.
       Luckily we have pseudo-class :checked on the radio input element to style our trick.
       Otherwise we would have to write event handler for the radio button events. 
       
       <input type="radio" class="form__radio-input" id="small" name="groupSize">
        <label for="small" class="form__radio-label">
            <span class="form__radio-button"></span>
            Small tour group
        </label>

        so when form__radio-input is checked, we want to get sibling form__radio-label and then get child of that
        which is form__radio-button and then we want to style form__radio-button's ::after pseudo element.

        So as soon as we hit the label element, the radio-input becomes checked.
        And what we do then is to simply select the sibling of that one, and then the child 
        because that's the one that we want to change each time that the radio input is selected.
        And we want to give it an opacity of 1.
       */ }
  .form__group:not(:last-child) {
    margin-bottom: 2rem; }
  .form__input {
    font-size: 1.5rem;
    /* Input elements usually don't inherit the font properties like font-family, color, etc. ,
           inlike other element. So we set it manually to what we have defined for this webpage. */
    font-family: inherit;
    color: inherit;
    padding: 1.5rem 2rem;
    border-radius: 2px;
    background-color: rgba(255, 255, 255, 0.5);
    border: none;
    width: 90%;
    display: block;
    transition: all .3s;
    /* IMPORTANT: 
           when you click on Full Name textbox, you will see that Email textbox moves down a bit,
           and that's because of the 3px that are a for the border in :focus selector below, 
           are being added. So we should actually add that border here in the initial state as well, 
           but reset it to transparent. 
           So it will be invisible in the normal state and then as soon as we click it, as it's focused. */
    border-bottom: 3px solid transparent;
    /* To style the input boxes based on the validity of the input value. 
           The input box will be invalid if the validation added on the element fails. e.g. 'required' */
    /*  pseudo elements represent things that are actually on the webpage.
            ::placeholder pseudo-element represents the placeholder text in an <input> or <textarea> element.
            Placeholder text should be light grey and as soon as we start typing, the text should become darker. */ }
    @media (max-width: 56.25em) {
      .form__input {
        width: 100%; } }
    .form__input:focus {
      outline: none;
      box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.1);
      border-bottom: 3px solid #55c57a; }
    .form__input:focus:invalid {
      border-bottom: 3px solid #ff7730; }
    .form__input::-webkit-input-placeholder {
      color: #999; }
    .form__input::-moz-placeholder {
      /* Firefox 19+ */
      color: #999; }
    .form__input:-ms-input-placeholder {
      /* IE 10+ */
      color: #999; }
    .form__input::placeholder {
      color: #999; }
  .form__label {
    font-size: 1.2rem;
    font-weight: 700;
    display: block;
    margin-left: 2rem;
    margin-top: .7rem;
    transition: all .5s; }
  .form__input:placeholder-shown + .form__label {
    /* opacity:0, then the element is basically still be on the page, but only invisible.
           When we set visibility: hidden, the element is just gone. 
           So why don't we just use the visibility hidden without the opacity?
           That's because we cannot animate the visibility, That's why we use the opacity to animate this effect. */
    opacity: 0;
    visibility: hidden;
    transform: translateY(-4rem); }
  .form__radio-group {
    width: 49%;
    display: inline-block; }
    @media (max-width: 56.25em) {
      .form__radio-group {
        width: 100%;
        margin-bottom: 2rem; } }
  .form__radio-input {
    display: none; }
  .form__radio-label {
    font-size: 1.6rem;
    cursor: pointer;
    position: relative;
    padding-left: 4.5rem; }
  .form__radio-button {
    height: 3rem;
    width: 3rem;
    border-radius: 50%;
    border: 5px solid #55c57a;
    display: inline-block;
    /* this is span element and span element is an inline element
                                  so in order for the height and width to work, block or inline-block is needed. */
    position: absolute;
    left: 0;
    top: -.4rem; }
    .form__radio-button::after {
      content: "";
      display: block;
      height: 1.3rem;
      width: 1.3rem;
      border-radius: 50%;
      background-color: #55c57a;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transform: opacity .2s; }
  .form__radio-input:checked ~ .form__radio-label .form__radio-button::after {
    opacity: 1; }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform .3s; }
  @media (max-width: 56.25em) {
    .feature-box {
      padding: 2rem; } }
  .feature-box__icon {
    /* Remember that an icon is effectively a font. 
           And so we can use font-size, in order to change the size of the icon. */
    font-size: 6rem;
    margin-bottom: .5rem;
    display: inline-block;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent; }
    @media (max-width: 56.25em) {
      .feature-box__icon {
        margin-bottom: 0; } }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.popup {
  position: fixed;
  top: 0;
  left: 0;
  height: 100vh;
  width: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 9999;
  opacity: 0;
  visibility: hidden;
  transition: all .3s;
  /* when we click on the 'Book Now' button on the back cards, then the anchor will basically become this popup,
       i.e. target, as we have anchored it to #popup div. 
       
       We have a pseudo class called target, which applies to an element which is the target 
       when we click on a button, or basically when the URL changes to having target in it. */
  /* We want to style the content at the moment where the popup is open. */ }
  .popup__content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 75%;
    background-color: #fff;
    border-radius: 3px;
    box-shadow: 0 2rem 4rem rgba(0, 0, 0, 0.2);
    overflow: hidden;
    /* to avoid image overlapping the border, 
                           so that part of the image which is overflowing this box will not be visible anymore. */
    /* With display: table; popup__content functions as a table. 
        We are basically faking and saying that this is a table.
        And then the popup__left and the popup__right they are both table cells.
        And then the browser will automatically give them the same height. */
    display: table;
    /* you can only have one transform property in each declaration block.
           If we have more than one transform property in one declaration block, it will not work.
           solution is to repeat the transform values to have desired effect. */
    transform: translate(-50%, -50%) scale(0.25);
    opacity: 0;
    /* Delay this transition here by .2 seconds. So that first we allow the black background
           to come in and then after that we fade in our popup box. */
    transition: all .5s .2s; }
  .popup__left {
    width: 33.333333%;
    /* We could use float to have popup__left and popup__right element side by side.
         But there is a problem with that. The popup__left takes the entire height,
         and then the popup__right one only has less height, of course, 
         because that's the space that it's content occupies.
         That's completely normal behavior.
         Now what we want here is that these boxes(left and right) actually have the SAME height 
         because then it's easier to center the content in the popup__right vertically in the middle
         of all of this white space. And so sometimes that's a very useful thing to do.

         There is a very ncie technique to achieve this - Using display:table-cell instead of floats. */
    display: table-cell; }
  .popup__right {
    width: 66.666666%;
    display: table-cell;
    vertical-align: middle;
    padding: 3rem 5rem; }
  .popup__img {
    display: block;
    width: 100%; }
  .popup__text {
    font-size: 1.4rem;
    margin-bottom: 4rem;
    /* Column layout is something really new in CSS, 
        but we can make it work in most of the modern browsers already.
        All we have to do is to specify a property called column-count. */
    -moz-column-count: 2;
    -moz-column-gap: 4rem;
    -moz-column-rule: 1px solid #eee;
    column-count: 2;
    column-gap: 4rem;
    column-rule: 1px solid #eee;
    -moz-hyphens: auto;
    -ms-hyphens: auto;
    -webkit-hyphens: auto;
    hyphens: auto;
    /*  It will automatically figure out where to place the hyphens.
                           It also nicely changes the hyphenation as the width changes.
                           But in order for this to work correctly, 
                           we have to define the document language e.g. <html lang="en"> */
    /* BTW These columns and the hyphens properties allows us to get closer 
           to the traditional print designs like a magazine layout or a real newspaper.
           That's why these properties were introduced. */ }
  .popup:target {
    opacity: 1;
    visibility: visible; }
  .popup:target .popup__content {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1; }
  .popup__close:link, .popup__close:visited {
    color: #777;
    position: absolute;
    top: .5rem;
    right: 1.5rem;
    font-size: 3rem;
    text-decoration: none;
    display: inline-block;
    line-height: 1;
    transition: all .2s; }
  .popup__close:hover, .popup__close:active {
    color: #55c57a; }

@media (max-width: 56.25em) {
  .popup__content {
    width: 85%; }
  .popup__left {
    width: 100%;
    display: table-row; }
  .popup__right {
    width: 100%;
    vertical-align: middle;
    padding: 2rem 3rem; }
    .popup__right .heading-secondary {
      display: block;
      text-align: center; }
    .popup__right .heading-tertiary {
      text-align: center; }
    .popup__right .btn {
      display: block;
      width: 60%;
      margin: 0 auto;
      text-align: center; }
  .popup__img {
    display: inline-block;
    width: 50%; }
  .popup__text {
    margin: 0 1.5rem 2rem 1.5rem;
    -moz-column-count: unset;
    -moz-column-gap: unset;
    -moz-column-rule: unset;
    column-count: unset;
    column-gap: unset;
    column-rule: unset; } }

.story {
  width: 75%;
  margin: 0 auto;
  box-shadow: 0 3rem 6rem rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
  padding: 6rem;
  padding-left: 9rem;
  font-size: 1.6rem;
  transform: skewX(-12deg); }
  @media (max-width: 56.25em) {
    .story {
      width: 100%;
      padding: 4rem;
      padding-left: 7rem; } }
  @media (max-width: 37.5em) {
    .story {
      transform: skewX(0); } }
  .story__shape {
    width: 15rem;
    height: 15rem;
    float: left;
    /* 
           shape-outside only works when you have specified width, height and float.
           shape outside - all it does is to define where the content floats around the element 
           in this case, a circle.
           And if we actually want the element to look like a circle, we need to use clip-path property.

           Circle radius to be 50% of the height and width specified. 
           bcz we want circle diameter to be equal to height and width of the this element.
           at 50% 50% means that the center of the circle to be exactly the center horizontally and vertically.
        */
    -webkit-shape-outside: circle(50% at 50% 50%);
    shape-outside: circle(50% at 50% 50%);
    -webkit-clip-path: circle(50% at 50% 50%);
    clip-path: circle(50% at 50% 50%);
    /* best way to move around an element that is floated is to actually not mess with margins 
           or anything like that, but we should just use a transform. */
    transform: translateX(-3rem) skewX(12deg);
    position: relative;
    /* since &__img scales the image, that adds horizontal/vertical scroll which we don't want. */
    overflow: hidden; }
    @media (max-width: 37.5em) {
      .story__shape {
        transform: translateX(-3rem) skewX(0); } }
  .story__img {
    /* Flexible images for responsive web design always need a width. Always, without any exception! */
    /* Here we have to use height: 100% instead of width: 100% 
           because this particular image is wider than it's height, 
           so if we give it a 100% width then, of course, it cannot fill this entire circle. */
    height: 100%;
    transform: translateX(-4rem) scale(1.4);
    /* Whenever we're dealing with animations and translating stuff, 
           when something weird happens, then many times this back face visibility fixes that.
           No one really knows why it happens this way or why this works this way, but it fixes it. */
    backface-visibility: hidden;
    transition: all .5s; }
  .story__text {
    transform: skewX(12deg); }
    @media (max-width: 37.5em) {
      .story__text {
        transform: skewX(0); } }
  .story__caption {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 20%);
    text-transform: uppercase;
    color: #fff;
    font-size: 1.7rem;
    text-align: center;
    opacity: 0;
    transition: all .5s;
    backface-visibility: hidden; }
  .story:hover .story__caption {
    opacity: 1;
    transform: translate(-50%, -50%); }
  .story:hover .story__img {
    transform: translateX(-4rem) scale(1);
    /* zoom out effect. Also need to pass translateX(-4rem)
                                                  which is same as initial position to have desired effect. */
    /* Very cool property - filter. 
           The filter CSS property applies graphical effects like blur or color shift to an element. 
           Filters are commonly used to adjust the rendering of images, backgrounds, and borders.
           
           It has lot of options like -
           blur, brightness, opacity, contrast, drop-shadow, grey-scale, hue-rotate, etc. */
    filter: blur(2px) brightness(80%); }

.footer {
  background-color: #333;
  color: #f7f7f7;
  padding: 10rem 0;
  font-size: 1.4rem; }
  @media (max-width: 56.25em) {
    .footer {
      padding: 8rem 0; } }
  .footer__logo-box {
    text-align: center;
    margin-bottom: 8rem; }
    @media (max-width: 56.25em) {
      .footer__logo-box {
        margin-bottom: 6rem; } }
  .footer__logo {
    width: 15rem;
    height: auto; }
  .footer__navigation {
    border-top: 1px solid #777;
    padding-top: 2rem;
    display: inline-block;
    /* to avoid border to go out of navigation links. 
                                  inline block does not occupy 100% of its available width, 
                                  only the one that the content needs.*/ }
    @media (max-width: 56.25em) {
      .footer__navigation {
        width: 100%;
        text-align: center; } }
  .footer__list {
    list-style: none; }
  .footer__item {
    display: inline-block; }
    .footer__item:not(:last-child) {
      margin-right: 1.5rem; }
  .footer__link:link, .footer__link:visited {
    background-color: #333;
    color: #f7f7f7;
    text-decoration: none;
    text-transform: uppercase;
    display: inline-block;
    transition: all .2s; }
  .footer__link:hover, .footer__link:active {
    color: #55c57a;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
    transform: rotate(5deg) scale(1.3); }
  .footer__copyright {
    border-top: 1px solid #777;
    padding-top: 2rem;
    width: 80%;
    float: right; }
    @media (max-width: 56.25em) {
      .footer__copyright {
        width: 100%;
        float: none; } }

.row {
  /*
        max-width means is that if we have enough available space, then it will have the width that we specified
        but if there is not enough width, so basically if the viewport is smaller than width that we specified,
        so in this case, if the viewport is smaller than 114 rem, then it will simply fill 100% of the available space.
    */
  max-width: 114rem;
  /* 
        That's the trick to center block elements inside of another block element.
        When we say that we want the margin to be automatically, this means that the browser, 
        when rendering the page, will automatically figure out the margin 
        that we want on the left and on the right side.
        And since it's both set to auto, it means that left and right will be the same, 
        and CSS will automatically calculate the left margin and the right margin, 
        and they will be the same, and so of course, the element will be centered.
    */
  margin: 0 auto;
  /*
        we should have some space, some gutter between these rows EXCEPT last child. 
        So imagine we have a layout, and then we have multiple rows, 
        and we naturally want some space between them.
    */
  /*
        It will select all of the elements in which the class attribute starts with "col-".
        
        ^= means starts with
        *= means contains
        $= means ends with

        There is a whole lot of applications for this kind of selector. 
        e.g. we could also select anchor elements, which have the target attribute set to blank, 
        so these are the links that open in a new tab when we click them, 
        and we could then style these ones differently than the regular links.
    */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
    @media (max-width: 56.25em) {
      .row:not(:last-child) {
        margin-bottom: 6rem; } }
  @media (max-width: 56.25em) {
    .row {
      max-width: 50rem;
      padding: 0 3rem; } }
  .row::after {
    /*  we always need to specify the content property, otherwise a pseudo element will not appear on the page, 
            and we want it empty because we don't want to see this element on the page. */
    content: "";
    display: table;
    clear: both;
    /* the property that actually performs this clearfix is the clear property.        
                        This would clear both floats, so float left and float right */ }
  .row [class^="col-"] {
    float: left;
    /*  set the width of all the columns to 100%. That's the easiest way to do it,
            and that's what's usually done on mobile devices. 
            So all the columns are basically transformed into rows.
            So the entire mobile webpage will have only one single column, basically. */ }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
      @media (max-width: 56.25em) {
        .row [class^="col-"]:not(:last-child) {
          margin-right: 0;
          margin-bottom: 6rem; } }
    @media (max-width: 56.25em) {
      .row [class^="col-"] {
        width: 100% !important; } }
  .row .col-1-of-2 {
    /*
        native calc() function allows us to make calculations where we can mix units.
        That's a big difference between doing native CSS calculations or doing them in Sass 
        because in Sass, we can also do operations of course but we cannot do them with multiple units,
        so we cannot for example mix rem with pixels, with percentages.
        That's because we compile our Sass file while we're developing the page, 
        so even before the page is served of course to the user 
        but this kind of calculation all depends on the layout, so it has to happen while the website is rendered
        using the visual formatting model. That's when these calculations can occur 
        because it's only then when CSS and when the browser knows what the percentage is, what the rem is, 
        and what all of that stuff is.
        */
    width: calc( (100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc( (100% - 2 * 6rem ) / 3); }
  .row .col-2-of-3 {
    width: calc( 2 * ((100% - 2 * 6rem ) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc( (100% - 3 * 6rem ) / 4); }
  .row .col-2-of-4 {
    width: calc( 2 * ((100% - 3 * 6rem ) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc( 3 * ((100% - 3 * 6rem ) / 4) + (2 * 6rem)); }

/*
    In the layouts folder we define the overall layout of the project e.g. global footer, header.
*/
/* Note this is 'header' class not <header> element */
.header {
  height: 95vh;
  /* 95% of viewport height bcz we have added padding for body element. */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  /* to cover whole viewport area so that whole image can be seen */
  background-position: top;
  /* ensure that whatever the viewport size is 
                                 the top of the image always stays at the top of the container. */
  position: relative;
  /* marking it as relative bcz .logo-box & .text-box are marked as absolute. */
  /* to clip out a part of the image. 
       There are multiple options but as per our need we need use polygon. 
       polygon just takes cordinates of how you want to see it.
         - for triangle - need to pass 3 cordinates,
         - for rectangle or any shape of 4 points - need to pass 4 cordinates, etc. 
    */
  -webkit-clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); }
  @media (max-width: 37.5em) {
    .header {
      -webkit-clip-path: polygon(0 0, 100% 0, 100% 85vh, 0 100%);
      clip-path: polygon(0 0, 100% 0, 100% 85vh, 0 100%); } }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    /* 40px from top w.r.t it's parent element which is header. so mark header as relative. 
                   If it's immediate parent is not marked as 'relative', 
                   then it checks for the reference of the first element with the relative position 
                   that it can find. If it cant's find any thing, it will take reference 
                   w.r.t viewport which is top of the window. */
    left: 4rem;
    /* 40px from top w.r.t it's parent element which is header. so mark header as relative. */ }
  .header__logo {
    height: 3.5rem;
    width: auto; }
  .header__text-box {
    /*
       top 40% and left 50% - are in relation to the parent element. 
       So 50% of the parent element is where the text box was located to the left side. 
       But, on the transform, when we use translate, this is in relation to the element itself.
       And this makes it possible that the element is exactly at the center.
       */
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center; }

.navigation {
  /* This is basically for showing entire screen gradient background 
       which we see when we click on the hamburger. */
  /* This would be a huge element occupying the entire viewport 
       so that we can then center the navigation list inside of that, both horizontally and vertically. */
  /* We hit the label and the checkbox becomes checked.
       Then we want the navigation background to become visible. */
  /* We hit the label and the checkbox becomes checked.
       Then we want the navigation to become visible. */
  /* When the checkbox is selected, then we select its immediate brother, which is called a button.
       Then, we select the button's child, which is the icon. */ }
  .navigation__checkbox {
    display: none; }
  .navigation__button {
    background-color: #fff;
    height: 7rem;
    width: 7rem;
    border-radius: 50%;
    position: fixed;
    /* That's because the button is 1rem wider and higher than the navigation__background 
           And that's why it's then half a rem further to the top and to the right. */
    top: 6rem;
    right: 6rem;
    z-index: 2000;
    box-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.1);
    text-align: center;
    cursor: pointer; }
    @media (max-width: 56.25em) {
      .navigation__button {
        top: 4rem;
        right: 4rem; } }
    @media (max-width: 37.5em) {
      .navigation__button {
        top: 3rem;
        right: 3rem; } }
  .navigation__background {
    height: 6rem;
    width: 6rem;
    border-radius: 50%;
    position: fixed;
    top: 6.5rem;
    right: 6.5rem;
    /* linear gradient goes from one side to the other one.
           while the radial gradient starts in the middle of an element and goes in all the outside directions. */
    background-image: radial-gradient(#7ed56f, #28b485);
    z-index: 1000;
    /* We have many built-in transition timing functions like ease-in, ease-out, ease-in-out,
           but we can create our own transition timing function using cubic-bezier().
           An easing function is, basically a function that specifies how much change occurs over time.
           Some predefined values for cubic-bezier() at https://easings.net */
    transition: transform 0.8s cubic-bezier(0.83, 0, 0.17, 1); }
    @media (max-width: 56.25em) {
      .navigation__background {
        top: 4.5rem;
        right: 4.5rem; } }
    @media (max-width: 37.5em) {
      .navigation__background {
        top: 3.5rem;
        right: 3.5rem; } }
  .navigation__nav {
    height: 100vh;
    /* Because remember that with the navigation open, even if you scroll, 
           the navigation will stay at the same place. */
    position: fixed;
    top: 0;
    right: 0;
    z-index: 1500;
    opacity: 0;
    width: 0;
    transition: all 0.8s cubic-bezier(0.68, -0.6, 0.32, 1.6); }
  .navigation__list {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    list-style: none;
    text-align: center;
    /* If width is not specified, then the navigation list is animated in such a way
           like weirdly moving in from the circle side and moving out from inside the circle. 
           Try by removing width to see the difference. You can slow down animation to see it closely :) */
    width: 100%; }
  .navigation__item {
    margin: 1rem; }
  .navigation__link {
    /* If we shift the background completely to the left side,then we end up with the effect that we want.
           And we can do that with background-position. */ }
    .navigation__link:link, .navigation__link:visited {
      display: inline-block;
      font-size: 3rem;
      font-weight: 300;
      padding: 1rem 2rem;
      color: #fff;
      text-decoration: none;
      text-transform: uppercase;
      background-image: linear-gradient(120deg, transparent 0%, transparent 50%, #fff 50%);
      /* We're basically increasing the entire thing. But it's not visible because the box ends.
               only the red part of this gradient is visible. 
               But we know that the white part is still here on the right side. */
      background-size: 230%;
      transition: all .4s; }
      .navigation__link:link span, .navigation__link:visited span {
        margin-right: 1.5rem;
        display: inline-block; }
    .navigation__link:hover, .navigation__link:active {
      background-position: 100%;
      color: #55c57a;
      transform: translateX(1rem); }
  .navigation__checkbox:checked ~ .navigation__background {
    transform: scale(80); }
  .navigation__checkbox:checked ~ .navigation__nav {
    opacity: 1;
    width: 100%; }
  .navigation__icon {
    position: relative;
    margin-top: 3.5rem; }
    .navigation__icon, .navigation__icon::before, .navigation__icon::after {
      width: 3rem;
      height: 2px;
      background-color: #333;
      display: inline-block; }
    .navigation__icon::before, .navigation__icon::after {
      /* In order for the before and after pseudo elements to actually appear on the page,                    
               they need to have their content and display properties defined. */
      content: "";
      position: absolute;
      left: 0;
      transition: all .2s; }
    .navigation__icon::before {
      top: -.8rem;
      /* transform origin it describes where the transformation happens.
               So in case of transform, the center of the rotation is at the right side of the element. 
               Sometimes, when we rotate something, this can be really helpful 
               in order to rotate it exactly where we want it. 
               If you don't specify it at all, then it's basically just in the center. */ }
    .navigation__icon::after {
      top: .8rem; }
  .navigation__button:hover .navigation__icon::before {
    top: -1rem; }
  .navigation__button:hover .navigation__icon::after {
    top: 1rem; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon {
    background-color: transparent; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon::before {
    transform: rotate(135deg);
    top: 0; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon::after {
    transform: rotate(-135deg);
    /* in the opposite direction of ::before so that it will create a cross (X)
                                       rotate 45 degrees but to have cool effect lets rotate in opposite direction. 
                                       180 - 45 = 135 */
    top: 0; }

/*
    Styles that are only going apply for the home/landing page.
*/
.section-about {
  background-color: #f7f7f7;
  padding: 25em 0;
  /* header height 95vh and header polygon is 75vh, hence to show above light grey background color
       until the clipped portion of the polygon we need to provide margin-top = 95-75 = 20
       But instead of moving the section down, we want to move up so give negative margin of -20vh */
  margin-top: -20vh; }
  @media (max-width: 56.25em) {
    .section-about {
      padding: 20em 0; } }

.section-features {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  background-size: cover;
  /* to cover whole viewport area so that whole image can be seen */
  background-position: top;
  /* ensure that whatever the viewport size is 
                                 the top of the image always stays at the top of the container. */
  /* To have skewed effect like header. There are 2 ways to do this
        1. Using clip-path property
           clip-path: polygon(0 25vh, 100% 0, 100% 75vh, 0 100%); 
        2. Using transform and skew functions.
    */
  transform: skewY(-7deg);
  margin-top: -10rem; }
  .section-features > * {
    transform: skewY(7deg); }
  @media (max-width: 56.25em) {
    .section-features {
      padding: 10em 0; } }

.section-tours {
  background-color: #f7f7f7;
  padding: 25em 0 15rem 0;
  margin-top: -10rem; }
  @media (max-width: 56.25em) {
    .section-tours {
      padding: 20em 0 10rem 0; } }

.section-stories {
  padding: 15rem 0;
  position: relative; }
  @media (max-width: 56.25em) {
    .section-stories {
      padding: 10rem 0; } }

.section-book {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
  @media (max-width: 56.25em) {
    .section-book {
      padding: 10rem 0; } }

.book {
  /*  PROBLEM:
        What we want is to have a clipped element on top of the background image, 
        but at some width it should be opaque and after that background image should be visible. 
        (See Booking form on page to better visualize this.)
        SOLUTIONS - We can solve this in 2 ways.
        1. One approach is to add another element and then on that element 
           we would use clip-path in order to make for that clipped shape.
        2. Using solid-color gradient - this is just another background-color that we have on top of the image.
           It can start from one side, wide all the way till some point and 
           then all of a sudden we can change it to a transparent color. */
  /*  Solid-color gradient: Very powerful.
        If we put two different colors at the SAME position/number(%), then what happens is that we get solid line.
        And, so we have physically a gradient between two solid colors. 
        And, that's why it is called as the solid-color gradient. */
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 50%, transparent 50%), url(../img/nat-10.jpg);
  background-size: 100%;
  /* or we can also set it to 100% (of the width) which also means cover, 
                            that's because cover stretches the image to occupy the entire container, 
                            where the background-image is applied.
                            100% what is does is to ensure that the image fits the container, in the "X" direction, basically. */
  border-radius: 3px;
  box-shadow: 0 2.2rem 4rem rgba(0, 0, 0, 0.15); }
  @media (max-width: 75em) {
    .book {
      background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 65%, transparent 65%), url(../img/nat-10.jpg);
      background-size: cover; } }
  @media (max-width: 56.25em) {
    .book {
      background-image: linear-gradient(to right, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 100%), url(../img/nat-10.jpg); } }
  .book__form {
    width: 50%;
    padding: 6rem; }
    @media (max-width: 75em) {
      .book__form {
        width: 65%; } }
    @media (max-width: 56.25em) {
      .book__form {
        width: 100%; } }
